{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to BitcoinPy Rationale: What is BitcoinPy Bitcoin has been around for almost 10 years now. However, despite its use as a store of value and a means of quickly transferring monetary value from A to B, it lacks any other use-case. However, during the recent years new ideas have emerged, one of which are \"Smart Contracts\" - virtual contracts which are settled based on the \"code's law\". Think of it as contracts, that have a hard coded set of when-then rules and which cannot be tampered with by any involved party. Ethereum is the first (and so far only) project that has created a well done and nicely useable smart contract ecosystem, although there have been numerous copy cat attempts which implemented their own blockchain layer and are now struggling with an alternation of adoption problems and 51\\% attacks. We want to suggest how smart contracts, in a similar fashion as implemented by Ethereum, could be brought to the Bitcoin blockchain. BitcoinPy can be considered a \"second layer\" addition to the original Bitcoin protocol. The goal is to enable Turing-complete smart contracts that run on the native Bitcoin blockchain. But that is not enough, our vision was to make it as simple as possible. While Ethereum requires either advanced low-level byte code skills, or proficiency in a custom programming language termed Solidity (a lack of a full understanding of this new language may result in things like the DAO hack or the Parity disaster ), our requirement was to keep it as simple as possible: in our solution, users simply code their smart contracts in Python, a language that many are already familiar with and, as such, are likely to avoid such expensive mistakes. Who the heck are you We are a group of long-haired, bearded geeks who truly believe in a wider blockchain adoption over the next decades. As such, we want to contribute our skills, ideas and thoughts on how things might be improved and how we could finally get one step closer to that mysterious \"Bitcoin killer application\" that so many are desperately craving for. Maybe, if you bump into one of us at a CCC or a defcon conference, you can get us to know personally. Other than that, we will not put our selfies or names on any webpage and we will not brag with our useless collection of academic degrees. Why? Because we can. A Fair Launch BitcoinPy can be considered launched the moment the code is available on GitHub and available for everyone to try out. We are not conducting any ICOs, we reject pre-mines and there will be no other pre-allocation of GAS. That is, the project launches in an entirely fair manner with no GAS in circulation. Everyone who wants to get some GAS will need to mine it on their own once the code is available. Even though some developers, who contribute to this project, might privately mine GAS on their own behalf, they have no advantage over anyone else. It's an even playing field. No Forks BitcoinPy is a second-layer addition to the existing Bitcoin protocol. As such, it is fully compatible with the entire Bitcoin network in its current stage and with all other traditional Bitcoin nodes running the unmodified Bitcoin core client. Therefore, BitcoinPy neither is a soft- nor hard fork splitting the network into two different chains. Early Launch Phase Since this project is still exeperimental technology, the launch will include an \"early bird\" phase where the execution of contracts can be halted centrally in case something goes wrong. Even though transactions are permanent, during this phase incorrectly executed contracts may be reverted or altered, in a way that they reflect what was originally intended. We expect this \"early bird\" phase to last a few weeks at most. Then, once it is confirmed that everything works as expected, this \"functionality\" will be removed entirely from the code. If you do not feel comfortable with this, please feel free to chime in once the \"early bird\" phase is over.","title":"Welcome to BitcoinPy"},{"location":"#welcome-to-bitcoinpy","text":"","title":"Welcome to BitcoinPy"},{"location":"#rationale","text":"","title":"Rationale:"},{"location":"#what-is-bitcoinpy","text":"Bitcoin has been around for almost 10 years now. However, despite its use as a store of value and a means of quickly transferring monetary value from A to B, it lacks any other use-case. However, during the recent years new ideas have emerged, one of which are \"Smart Contracts\" - virtual contracts which are settled based on the \"code's law\". Think of it as contracts, that have a hard coded set of when-then rules and which cannot be tampered with by any involved party. Ethereum is the first (and so far only) project that has created a well done and nicely useable smart contract ecosystem, although there have been numerous copy cat attempts which implemented their own blockchain layer and are now struggling with an alternation of adoption problems and 51\\% attacks. We want to suggest how smart contracts, in a similar fashion as implemented by Ethereum, could be brought to the Bitcoin blockchain. BitcoinPy can be considered a \"second layer\" addition to the original Bitcoin protocol. The goal is to enable Turing-complete smart contracts that run on the native Bitcoin blockchain. But that is not enough, our vision was to make it as simple as possible. While Ethereum requires either advanced low-level byte code skills, or proficiency in a custom programming language termed Solidity (a lack of a full understanding of this new language may result in things like the DAO hack or the Parity disaster ), our requirement was to keep it as simple as possible: in our solution, users simply code their smart contracts in Python, a language that many are already familiar with and, as such, are likely to avoid such expensive mistakes.","title":"What is BitcoinPy"},{"location":"#who-the-heck-are-you","text":"We are a group of long-haired, bearded geeks who truly believe in a wider blockchain adoption over the next decades. As such, we want to contribute our skills, ideas and thoughts on how things might be improved and how we could finally get one step closer to that mysterious \"Bitcoin killer application\" that so many are desperately craving for. Maybe, if you bump into one of us at a CCC or a defcon conference, you can get us to know personally. Other than that, we will not put our selfies or names on any webpage and we will not brag with our useless collection of academic degrees. Why? Because we can.","title":"Who the heck are you"},{"location":"#a-fair-launch","text":"BitcoinPy can be considered launched the moment the code is available on GitHub and available for everyone to try out. We are not conducting any ICOs, we reject pre-mines and there will be no other pre-allocation of GAS. That is, the project launches in an entirely fair manner with no GAS in circulation. Everyone who wants to get some GAS will need to mine it on their own once the code is available. Even though some developers, who contribute to this project, might privately mine GAS on their own behalf, they have no advantage over anyone else. It's an even playing field.","title":"A Fair Launch"},{"location":"#no-forks","text":"BitcoinPy is a second-layer addition to the existing Bitcoin protocol. As such, it is fully compatible with the entire Bitcoin network in its current stage and with all other traditional Bitcoin nodes running the unmodified Bitcoin core client. Therefore, BitcoinPy neither is a soft- nor hard fork splitting the network into two different chains.","title":"No Forks"},{"location":"#early-launch-phase","text":"Since this project is still exeperimental technology, the launch will include an \"early bird\" phase where the execution of contracts can be halted centrally in case something goes wrong. Even though transactions are permanent, during this phase incorrectly executed contracts may be reverted or altered, in a way that they reflect what was originally intended. We expect this \"early bird\" phase to last a few weeks at most. Then, once it is confirmed that everything works as expected, this \"functionality\" will be removed entirely from the code. If you do not feel comfortable with this, please feel free to chime in once the \"early bird\" phase is over.","title":"Early Launch Phase"},{"location":"contracts/","text":"Python Contracts General Overview BitcoinPy contracts are developed in Python. Period. There are no additional annotations or code gimmicks that you need to learn. One of the most important things for us was to make the use of smart contracts as simple as possible. The only restriction that applies is, that you cannot use all of the traditional modules that you find in most Python distributions. While you can use all the power that the language gives you, modules that would give you access to the filesystem, network or other evil parts are not present. In face, the only module you can import and use is the Blockchain module. Blockchain Module The Blockchain module is a module that can be imported and used by any smart contract. While it is not part of a standard Python distribution, you are advised to use our own Python interpreter (contractpython) to develop and test your smart contracts. This is an overview of the entire functionality of the Blockchain module: Function or Object Type Description blockchain.store Dictionary A python dictionary object. Everything you store here will be stored permanently on the blockchain. Values may be overwritten. blockchain.current_block_height() Numeric The height of the block this transaction was included into blockchain.current_block_time() Numeric The timestamp of the block this transaction was included into blockchain.current_block_id() Hex String The hex encoded block hash of the current block blockchain.previous_block_time() Numeric The timestamp of the previous block blockchain.previous_block_id() Hex String The hex encoded block hash of the previousblock blockchain.tx_value() Numeric The GAS value that was submitted with this transaction in satoshis blockchain.contract_balance() Numeric The contract's current balance in satoshis blockchain.gas_left() Numeric Every user specifies a maximum gas amount to be used when calling a contract - let us call this GAS fee. This value indicates the amount of GAS-fee left at a certain point in the contract execution flow blockchain.contract_id() Address String The address of the contract blockchain.tx_sender() Address String The address of the transaction's sender blockchain.random() Numeric A pseudo-random 32 bit integer that comes from a random number generator that was seeded using parameters from the current Bitcoin blockchain's state blockchain.send(address, value) Void This call makes the contract send \"value\" to \"address\" from its contract balance blockchain.suicide(address) Void This call sends the entire balance of the contract to \"address\" and suicides, i.e., makes the contract unusable in the future blockchain. assert_address_check(address) Void Allows you to check for the validity of a Bitcoin address. This call reverts the contract execution if an invalid address was provided. The caller just pays the GAS fees, but not the GAS amount he sent to the contract blockchain.revert() Void Reverts the contract execution. The caller just pays the GAS fees, but not the GAS amount he sent to the contract Balance Behavior A user who calls a contract usually specifies two things. A \"value\" in GAS that he is sending to a contract (as a bet to our coin toss game for example, but it can be also 0) and a maximum \"GAS fee\", which is the maximum amount of GAS that he is willing to pay for the contract execution. Depending on the outcome of the contract execution, the user is either only paying the GAS fee, or paying the GAS fee plus the amount of GAS he is transferring to the contract. Here is a matrix that shows you all possible outcomes: Event What does the user pay Contract executes fine GAS fee + transferred GAS Contract suicides GAS fee + transferred GAS Contract cannot execute properly and throws an exception GAS fee Contract reverts using blockchain.revert() GAS fee Contract cannot be called (insufficient balance or contract dead) Nothing","title":"Python Contracts"},{"location":"contracts/#python-contracts","text":"","title":"Python Contracts"},{"location":"contracts/#general-overview","text":"BitcoinPy contracts are developed in Python. Period. There are no additional annotations or code gimmicks that you need to learn. One of the most important things for us was to make the use of smart contracts as simple as possible. The only restriction that applies is, that you cannot use all of the traditional modules that you find in most Python distributions. While you can use all the power that the language gives you, modules that would give you access to the filesystem, network or other evil parts are not present. In face, the only module you can import and use is the Blockchain module.","title":"General Overview"},{"location":"contracts/#blockchain-module","text":"The Blockchain module is a module that can be imported and used by any smart contract. While it is not part of a standard Python distribution, you are advised to use our own Python interpreter (contractpython) to develop and test your smart contracts. This is an overview of the entire functionality of the Blockchain module: Function or Object Type Description blockchain.store Dictionary A python dictionary object. Everything you store here will be stored permanently on the blockchain. Values may be overwritten. blockchain.current_block_height() Numeric The height of the block this transaction was included into blockchain.current_block_time() Numeric The timestamp of the block this transaction was included into blockchain.current_block_id() Hex String The hex encoded block hash of the current block blockchain.previous_block_time() Numeric The timestamp of the previous block blockchain.previous_block_id() Hex String The hex encoded block hash of the previousblock blockchain.tx_value() Numeric The GAS value that was submitted with this transaction in satoshis blockchain.contract_balance() Numeric The contract's current balance in satoshis blockchain.gas_left() Numeric Every user specifies a maximum gas amount to be used when calling a contract - let us call this GAS fee. This value indicates the amount of GAS-fee left at a certain point in the contract execution flow blockchain.contract_id() Address String The address of the contract blockchain.tx_sender() Address String The address of the transaction's sender blockchain.random() Numeric A pseudo-random 32 bit integer that comes from a random number generator that was seeded using parameters from the current Bitcoin blockchain's state blockchain.send(address, value) Void This call makes the contract send \"value\" to \"address\" from its contract balance blockchain.suicide(address) Void This call sends the entire balance of the contract to \"address\" and suicides, i.e., makes the contract unusable in the future blockchain. assert_address_check(address) Void Allows you to check for the validity of a Bitcoin address. This call reverts the contract execution if an invalid address was provided. The caller just pays the GAS fees, but not the GAS amount he sent to the contract blockchain.revert() Void Reverts the contract execution. The caller just pays the GAS fees, but not the GAS amount he sent to the contract","title":"Blockchain Module"},{"location":"contracts/#balance-behavior","text":"A user who calls a contract usually specifies two things. A \"value\" in GAS that he is sending to a contract (as a bet to our coin toss game for example, but it can be also 0) and a maximum \"GAS fee\", which is the maximum amount of GAS that he is willing to pay for the contract execution. Depending on the outcome of the contract execution, the user is either only paying the GAS fee, or paying the GAS fee plus the amount of GAS he is transferring to the contract. Here is a matrix that shows you all possible outcomes: Event What does the user pay Contract executes fine GAS fee + transferred GAS Contract suicides GAS fee + transferred GAS Contract cannot execute properly and throws an exception GAS fee Contract reverts using blockchain.revert() GAS fee Contract cannot be called (insufficient balance or contract dead) Nothing","title":"Balance Behavior"},{"location":"mining/","text":"Mining General Information Whenever contracts are executed, a little gas has to be payed by the caller as an execution fee. The amount of gas is highly depending on the complexity of the contract and is stored into an accumulator. Once a valid mining transaction is seen on the network, the miner takes all gas that has been accumulated up to that point. Technically, mining transactions are broadcast as normal, regular transactions on the Bitcoin network. They do not provide any strength to a consensus and only pose the purpose to a) distribute all (maximum possible) 3141592 GAS over time, and b) feed the GAS fees, that were collected for contract execution, back into the eco system. That also means, that multiple mine transactions may be included in one Bitcoin block. Each transaction, to be precise, is looked at in the order it appears in the block: so when there is GAS left in the GAS accumulator, and there are two mine transactions in a block without any other contract execution transactions in between them, each of both gets the mining reward, yet only the first one gets the content of the accumulator. Retargeting Similar to Bitcoin, the difficulty of the mining transactions is represented by a 256bit number. The \"mining hash\" of the transaction (see below) has to be below this target value to be eligible to claim the GAS rewards. The initial target value is set to 0x000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff [ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000 big endian] and is re-adjusted every 64 blocks or roughly 640 minutes in a way that a) there is on average one mining transaction every 10 minutes and b) the change of the target value is less than, or equal to, 25% between two consecutive retargets. The look-behind period, i.e., the period looked at to average the mining transaction times, are 64 blocks as well. The Hashing Mechanism In order to obtain a valid mining transaction, you need to repeatedly double-SHA256 a byte string like this: 2e7a893a02608d5f70185933873dd73e3ea4c8b1e12d0277da851dc5ecceeb4807f2e97500af9b5c0532de416e73b08323f23db2dc5ff547e4937d0545ee44ac000000000000000000000000000000000000000023324e3958747167416544486d4d345a71333259687a615574503761386e534455445a41100fbb5bcc1d1aaab2ba481d57f1c56e72 Let's break down the exact meaning: Bytes Bytes Meaning 2e7a893a02608d5f70185933873dd73e3 ea4c8b1e12d0277da851dc5ecceeb48 32 The milestone block ID in big endian form. If you obtain it from a block explorer, you will most likely have to byte-reverse it. In this example, the \"commonly understood\" block ID would be 0x48ebce... 07f2e97500af9b5c0532de416e73b08323 f23db2dc5ff547e4937d0545ee44ac 32 The transaction ID of the first COutPoint, used in the inputs of your transaction. Same endianness transformation as in the point before applies 00000000 4 Big endian VOUT of the COutPoint used. If you have more than one input in your transaction, this and the last step (i.e. 36 bytes) have to be repeated for each of them. 03 1 Constant 0x03 = means this is a mining transaction 0000000000000000 8 Must be all zero 0000000000000000 8 Must be all zero 23 1 The length indicator of the following field in bytes 324e3958747167416544486d4d345a713 33259687a615574503761386e534455445a41 23 (might vary) The string representation of the receipient address (for the GAS rewards) byte encoded 10 1 Must be constant 0x10 - means that 16 bytes are following 0fbb5bcc1d1aaab2ba481d57f1c56e72 16 These are 16 random bytes that you can shuffle when trying to find a byte string for which the hash meets the target requirement The first 32 byte, the milestone block ID, can be calculated as follows: let us assume we estimate that our mining transaction will be included in block X+1 (assuming we are currently in block X). The milestone block id, in this case, would be floor((X+1)/10)*10 , i.e., the block number rounded down to full 10's. In case X+1 already is 0 (mod 10), then we have to take the block id of block (X+1 - 10). Again, be advised that we need to hash the big endian form of the block hash. In case you do not want to construct this byte string yourself, you can issue the following command via RPC: minegastemplate 2N9XtqgAeDHmM4Zq32YhzaUtP7a8nSDUDZA And you will get back the \"transaction\", which is the byte string as described above pre-configured to pay the GAS rewards to the address specified above, the current target value as well as the milestone block ID (in little endian form): {'transaction': '030000000000000000000000000000000023324e3958747167416544486d4d345a71333259687a615574503761386e534455445a411055555555555555555555555555555555','target': 'efffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff','milestone': '48ebceecc51d85da77022de1b1c8a43e3ed73d87335918705f8d60023a897a2e'} The same principles from above apply ... the last 16 bytes (here, all 0x55) can be modifies, and then the whole block can be hashed according to the rules described earlier. Pushing to the Network Once you have found a solution, you can push the raw bytestring (All bytes above without the milestone block ID and the COutPoints) to the network by issuing the following RPC commands: a) Obtaining a raw Bitcoin transaction that encodes the mining payload using sendrawcontractpacket [{\"txid\": \"your used COutPoint txid\", \"vout\" : COutPoint.vout}] your_bytestring Make sure, that you include all COutPoints in case you used more than one! b) Signing this raw transaction, for example using your wallet: signrawtransactionwithwallet HEX STRING OF THE TRANSACTION FROM LAST STEP c) Last but not least: sendrawtransaction SIGNED HEX STRING OF THE TRANSACTION FROM LAST STEP Inefficient \"Reference Miner\" This principle is implemented in our quite inefficient, but easy to understand, reference miner implementation that you can find here .","title":"Mining"},{"location":"mining/#mining","text":"","title":"Mining"},{"location":"mining/#general-information","text":"Whenever contracts are executed, a little gas has to be payed by the caller as an execution fee. The amount of gas is highly depending on the complexity of the contract and is stored into an accumulator. Once a valid mining transaction is seen on the network, the miner takes all gas that has been accumulated up to that point. Technically, mining transactions are broadcast as normal, regular transactions on the Bitcoin network. They do not provide any strength to a consensus and only pose the purpose to a) distribute all (maximum possible) 3141592 GAS over time, and b) feed the GAS fees, that were collected for contract execution, back into the eco system. That also means, that multiple mine transactions may be included in one Bitcoin block. Each transaction, to be precise, is looked at in the order it appears in the block: so when there is GAS left in the GAS accumulator, and there are two mine transactions in a block without any other contract execution transactions in between them, each of both gets the mining reward, yet only the first one gets the content of the accumulator.","title":"General Information"},{"location":"mining/#retargeting","text":"Similar to Bitcoin, the difficulty of the mining transactions is represented by a 256bit number. The \"mining hash\" of the transaction (see below) has to be below this target value to be eligible to claim the GAS rewards. The initial target value is set to 0x000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff [ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000 big endian] and is re-adjusted every 64 blocks or roughly 640 minutes in a way that a) there is on average one mining transaction every 10 minutes and b) the change of the target value is less than, or equal to, 25% between two consecutive retargets. The look-behind period, i.e., the period looked at to average the mining transaction times, are 64 blocks as well.","title":"Retargeting"},{"location":"mining/#the-hashing-mechanism","text":"In order to obtain a valid mining transaction, you need to repeatedly double-SHA256 a byte string like this: 2e7a893a02608d5f70185933873dd73e3ea4c8b1e12d0277da851dc5ecceeb4807f2e97500af9b5c0532de416e73b08323f23db2dc5ff547e4937d0545ee44ac000000000000000000000000000000000000000023324e3958747167416544486d4d345a71333259687a615574503761386e534455445a41100fbb5bcc1d1aaab2ba481d57f1c56e72 Let's break down the exact meaning: Bytes Bytes Meaning 2e7a893a02608d5f70185933873dd73e3 ea4c8b1e12d0277da851dc5ecceeb48 32 The milestone block ID in big endian form. If you obtain it from a block explorer, you will most likely have to byte-reverse it. In this example, the \"commonly understood\" block ID would be 0x48ebce... 07f2e97500af9b5c0532de416e73b08323 f23db2dc5ff547e4937d0545ee44ac 32 The transaction ID of the first COutPoint, used in the inputs of your transaction. Same endianness transformation as in the point before applies 00000000 4 Big endian VOUT of the COutPoint used. If you have more than one input in your transaction, this and the last step (i.e. 36 bytes) have to be repeated for each of them. 03 1 Constant 0x03 = means this is a mining transaction 0000000000000000 8 Must be all zero 0000000000000000 8 Must be all zero 23 1 The length indicator of the following field in bytes 324e3958747167416544486d4d345a713 33259687a615574503761386e534455445a41 23 (might vary) The string representation of the receipient address (for the GAS rewards) byte encoded 10 1 Must be constant 0x10 - means that 16 bytes are following 0fbb5bcc1d1aaab2ba481d57f1c56e72 16 These are 16 random bytes that you can shuffle when trying to find a byte string for which the hash meets the target requirement The first 32 byte, the milestone block ID, can be calculated as follows: let us assume we estimate that our mining transaction will be included in block X+1 (assuming we are currently in block X). The milestone block id, in this case, would be floor((X+1)/10)*10 , i.e., the block number rounded down to full 10's. In case X+1 already is 0 (mod 10), then we have to take the block id of block (X+1 - 10). Again, be advised that we need to hash the big endian form of the block hash. In case you do not want to construct this byte string yourself, you can issue the following command via RPC: minegastemplate 2N9XtqgAeDHmM4Zq32YhzaUtP7a8nSDUDZA And you will get back the \"transaction\", which is the byte string as described above pre-configured to pay the GAS rewards to the address specified above, the current target value as well as the milestone block ID (in little endian form): {'transaction': '030000000000000000000000000000000023324e3958747167416544486d4d345a71333259687a615574503761386e534455445a411055555555555555555555555555555555','target': 'efffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff','milestone': '48ebceecc51d85da77022de1b1c8a43e3ed73d87335918705f8d60023a897a2e'} The same principles from above apply ... the last 16 bytes (here, all 0x55) can be modifies, and then the whole block can be hashed according to the rules described earlier.","title":"The Hashing Mechanism"},{"location":"mining/#pushing-to-the-network","text":"Once you have found a solution, you can push the raw bytestring (All bytes above without the milestone block ID and the COutPoints) to the network by issuing the following RPC commands: a) Obtaining a raw Bitcoin transaction that encodes the mining payload using sendrawcontractpacket [{\"txid\": \"your used COutPoint txid\", \"vout\" : COutPoint.vout}] your_bytestring Make sure, that you include all COutPoints in case you used more than one! b) Signing this raw transaction, for example using your wallet: signrawtransactionwithwallet HEX STRING OF THE TRANSACTION FROM LAST STEP c) Last but not least: sendrawtransaction SIGNED HEX STRING OF THE TRANSACTION FROM LAST STEP","title":"Pushing to the Network"},{"location":"mining/#inefficient-reference-miner","text":"This principle is implemented in our quite inefficient, but easy to understand, reference miner implementation that you can find here .","title":"Inefficient \"Reference Miner\""},{"location":"tokensfees/","text":"Tokens and Fees The GAS Token The GAS token, just as the BTC, is stored on the Bitcoin blockchain. It is needed to pay for the execution of the Python based smart contracts. More specifically, each opcode that is executed inside the Python virtual machine, costs currently 100 GAS satoshi, which translates to 0.000001 GAS. The denomination of 1 GAS into GAS satoshi is equal to the BTC denomination. Additionally to the opcodes, each byte either printed to the console or stored in the contract's permanent memory costs additional 100 GAS satoshi. GAS, that is used by the contracts, goes to the GAS miners. At this point it is worth to mention, that certain operators (such as the exponentiation or the modulus operator) internally consist of loops that repeatetly run multiple opcodes. This can cause to bump up the GAS costs quickly. The maximum possible supply of GAS is 3141592 GAS: miners are getting a certain amount of GAS which is decreasing as the time goes by. After the last GAS has been mined, the miners' rewards are limited to the GAS fees, that were acumulated since the last \"mine gas\" transaction. Transaction Fees GAS tokens are used as a \"fee\", or \"fuel\", for the execution of contracts. However, since we are operating on the Bitcoin blockchain, we still need to pay a small network relay fee. That means, in order to use BitcoinPy contracts, you need a small amount of BTC to broadcast things into the Bitcoin network, and GAS to actually fuel the execution of the smart contracts. While this may sound complicated at first, we made sure that the BitcoinQt GUI handles most of the hassle for you without you even noticing.","title":"Tokens and Fees"},{"location":"tokensfees/#tokens-and-fees","text":"","title":"Tokens and Fees"},{"location":"tokensfees/#the-gas-token","text":"The GAS token, just as the BTC, is stored on the Bitcoin blockchain. It is needed to pay for the execution of the Python based smart contracts. More specifically, each opcode that is executed inside the Python virtual machine, costs currently 100 GAS satoshi, which translates to 0.000001 GAS. The denomination of 1 GAS into GAS satoshi is equal to the BTC denomination. Additionally to the opcodes, each byte either printed to the console or stored in the contract's permanent memory costs additional 100 GAS satoshi. GAS, that is used by the contracts, goes to the GAS miners. At this point it is worth to mention, that certain operators (such as the exponentiation or the modulus operator) internally consist of loops that repeatetly run multiple opcodes. This can cause to bump up the GAS costs quickly. The maximum possible supply of GAS is 3141592 GAS: miners are getting a certain amount of GAS which is decreasing as the time goes by. After the last GAS has been mined, the miners' rewards are limited to the GAS fees, that were acumulated since the last \"mine gas\" transaction.","title":"The GAS Token"},{"location":"tokensfees/#transaction-fees","text":"GAS tokens are used as a \"fee\", or \"fuel\", for the execution of contracts. However, since we are operating on the Bitcoin blockchain, we still need to pay a small network relay fee. That means, in order to use BitcoinPy contracts, you need a small amount of BTC to broadcast things into the Bitcoin network, and GAS to actually fuel the execution of the smart contracts. While this may sound complicated at first, we made sure that the BitcoinQt GUI handles most of the hassle for you without you even noticing.","title":"Transaction Fees"}]}